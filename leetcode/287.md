> Problem: [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/description/)

[TOC]

看到 [这个老哥的九种解法](http://www.longluo.me/blog/2022/03/29/Leetcode-find-the-duplicate-number_cn/) ， 仿写下rust的九种写法。


![CopyQ.dcuBFp.png](https://pic.leetcode.cn/1691943203-SVXOrI-CopyQ.dcuBFp.png)

# 解法 1：排序法
## 题目思路解析：

这个解法的思路是先对输入数组进行排序，然后遍历数组找到相邻重复的元素。
## 具体步骤说明：

- 对输入的 nums 数组进行排序。
- 遍历排序后的数组，比较当前元素与前一个元素是否相等，如果相等，则找到了重复的数字。

## 复杂度分析：

- 时间复杂度：排序的时间复杂度为 O(n log n)，遍历数组的时间复杂度为 O(n)，所以总体时间复杂度为 O(n log n)。
- 空间复杂度：排序可能会使用 O(log n) 的额外空间（取决于排序算法），除此之外没有使用其他额外空间，所以空间复杂度为 O(log n)。

## 综合点评：

这个解法简单直接，但由于排序的时间复杂度较高，不是最优解法。

```rust
impl Solution {
    pub fn find_duplicate(mut nums: Vec<i32>) -> i32 {
        nums.sort(); // 对数组进行排序
        let mut prev_num = -1; // 用于记录前一个数字
        *nums.iter().find(|&&num| { // 遍历数组
            let found = num == prev_num; // 检查是否与前一个数字相等
            prev_num = num; // 更新前一个数字
            found // 返回是否找到相邻重复的数字
        }).unwrap() // 返回找到的重复数字
    }
}
```
# 解法 2：计数法
## 题目思路解析：

这个解法的思路是使用一个额外的数组 count 来记录每个数字出现的次数，然后遍历输入数组，将对应数字的计数加一，如果计数大于 1，则找到了重复的数字。
## 具体步骤说明：

- 创建一个大小与输入数组 nums 一样的计数数组 count，初始值全为 0。
- 遍历输入数组 nums，对每个数字 num，将 count[num] 加一。
- 在遍历过程中，如果发现某个数字的计数 count[num] 大于 1，则找到了重复的数字。

## 复杂度分析：

- 时间复杂度：遍历数组的时间复杂度为 O(n)，其中 n 是数组的长度。
- 空间复杂度：使用了一个大小为 n 的额外计数数组，所以空间复杂度为 O(n)。

## 综合点评：

这个解法在时间和空间复杂度上都相对较好，但需要使用额外的数组来记录计数。

```rust

impl Solution {
    pub fn find_duplicate(nums: Vec<i32>) -> i32 {
        let mut count = vec![0; nums.len()]; // 创建计数数组
        *nums.iter().find(|&&num| { // 遍历数组
            count[num as usize] += 1; // 增加计数
            count[num as usize] > 1 // 检查计数是否大于 1
        }).unwrap() // 返回找到的重复数字
    }
}
```

# 解法 3：哈希表法
## 题目思路解析：

这个解法的思路是使用一个哈希集合来记录已经出现过的数字，然后遍历输入数组，将每个数字加入哈希集合中，如果遇到重复的数字，则返回该数字。
## 具体步骤说明：

- 创建一个空的哈希集合 seen。
- 遍历输入数组 nums，对每个数字 num，检查是否在哈希集合 seen 中。如果不在，将该数字加入 seen 中；如果在，则找到了重复的数字。

## 复杂度分析：

- 时间复杂度：遍历数组的时间复杂度为 O(n)，其中 n 是数组的长度。哈希集合的插入和查找操作平均情况下的时间复杂度是 O(1)。
- 空间复杂度：使用了一个哈希集合来记录出现过的数字，所以空间复杂度取决于数组中不同的数字数量，最坏情况下为 O(n)。

## 综合点评：

这个解法相对较好，但需要使用额外的哈希集合来记录已经出现过的数字。
详细注释：

```rust

impl Solution {
    pub fn find_duplicate(mut nums: Vec<i32>) -> i32 {
        let mut seen = std::collections::HashSet::new(); // 创建哈希集合
        *nums.iter().find(|&&num| { // 遍历数组
            !seen.insert(num) // 将数字加入哈希集合，并检查是否已经存在
        }).unwrap() // 返回找到的重复数字
    }
}
```
# 解法 4：标记法（修改原数组）
## 题目思路解析：

这个解法的思路是通过修改原数组来标记已经遍历过的数字。遍历数组，对每个数字取绝对值，将对应索引处的数字变为负数。如果遇到一个已经为负数的数字，说明之前已经遍历过，返回这个数字。
## 具体步骤说明：

- 遍历输入数组 nums，对于每个索引 i 处的数字 num，取绝对值 val = nums[i].abs()。
- 如果 nums[val as usize] 为负数，则说明之前已经遍历过 val，即 val 是重复的数字，返回 val。
- 否则，将 nums[val as usize] 变为负数，表示已经遍历过 val。

## 复杂度分析：

- 时间复杂度：遍历数组的时间复杂度为 O(n)，其中 n 是数组的长度。
- 空间复杂度：未使用额外的数据结构，所以空间复杂度为 O(1)。

## 综合点评：

这个解法修改了原数组，不需要额外的数据结构，但可能会改变原数组的状态。
详细注释：

```rust

impl Solution {
    pub fn find_duplicate(mut nums: Vec<i32>) -> i32 {
        for i in 0..nums.len() {
            let val = nums[i].abs(); // 取绝对值
            if nums[val as usize] < 0 { // 判断是否已经遍历过
                return val; // 返回重复的数字
            }
            nums[val as usize] = -nums[val as usize]; // 标记为负数
        }
        unreachable!() // 没有找到重复的数字（不应该执行到这里）
    }
}
```
# 解法 5：索引-值 sort（修改原数组）
## 题目思路解析：
假定一个排序即 num[i]-1这个值应该在i这个索引位置上，如果不在，就交换nums[nums[i]-1]和nums[i]的值(就是把现在i处的值放到该去的地方，但是换过来的值不一定换正确了)。在当前i处不停的交换过程中，如果遇到nums[i](当前位置的值被换过来的，并且不是nums[i] - 1 == i这个假定的顺序)等于nums[nums[i]-1]](之前交换过去的正确值或者本来就是正确值)，就说明遇到重复的了。

(因为索引和值不是一一对应的关系，所以可以假定一个一一对应的映射关系，通过索引的一步步向后并且交换值达到正确映射关系的过程，来找到重复值)

(因为有重复，并且这个交换过程有操作未知值(nums[nums[i]-1]]这个值其实是未知的)，所以交换过程肯定会发现重复，就是一个未知值即还没有确定正确映射索引，竟然和正确映射索引重复了)

(就是一个未知值被换过来了，发现自己的值不适合当前这个索引，要再换到正确索引上，竟然发现正确索引上已经有正确值了，这两个都应该是那个正解索引上的正确值，并且索引和值一一对应，说明遇到重复的) 这个过程肯定会发生，因为有重复值。

## 具体步骤说明：

- 遍历数组，对于每个索引 i 处的数字 num，将其与索引 num - 1 处的数字交换，直到当前数字在正确的位置上。
- 如果遇到一个索引处的数字与应该在的位置上的数字相同，则找到了重复的数字。

复杂度分析：

- 时间复杂度：遍历数组的时间复杂度为 O(n)，其中 n 是数组的长度。每个数字最多交换一次，所以总体时间复杂度为 O(n)。
- 空间复杂度：未使用额外的数据结构，所以空间复杂度为 O(1)。

## 综合点评：

这个解法修改了原数组，不需要额外的数据结构，但可能会改变原数组的状态。
详细注释：

```rust

impl Solution {
    pub fn find_duplicate(mut nums: Vec<i32>) -> i32 {
        for i in 0..nums.len() {
            while nums[i] - 1 != i as i32 {
                let val = nums[i];
                if nums[(val - 1) as usize] == val {
                    return val; // 找到重复的数字
                }
                nums.swap(i, (val - 1) as usize); // 交换数字
            }
        }
        unreachable!() // 没有找到重复的数字（不应该执行到这里）
    }
}
```

# 解法 6：暴力法（时间超时）
## 题目思路解析：

这个解法的思路是通过嵌套循环来暴力检查每个数字是否是重复的。对于每个数字，使用内层循环来统计数组中相同的数字的个数，如果个数大于 1，则找到了重复的数字。
## 具体步骤说明：

- 遍历数组，对于每个数字 num，使用内层循环来统计数组中相同的数字的个数。
- 如果个数大于 1，则找到了重复的数字。

## 复杂度分析：

- 时间复杂度：两层嵌套循环，外层遍历数组，内层遍历数组来统计数字个数，总体时间复杂度为 O(n^2)，其中 n 是数组的长度。
- 空间复杂度：没有使用额外的数据结构，所以空间复杂度为 O(1)。

## 综合点评：

这个解法的时间复杂度相对较高，不太适合处理大规模数据。
详细注释：

```rust

impl Solution {
    pub fn find_duplicate(nums: Vec<i32>) -> i32 {
        *nums.iter()
            .find(|&&num| nums.iter().filter(|&&x| x == num).count() > 1) // 统计相同数字的个数
            .unwrap() // 返回找到的重复数字
    }
}
```
# 解法 7：二分查找法
## 题目思路解析：

正常的1到n 它们的 count(数组里面小于等于本身的个数)应该是<=本身的 
例如 [1,2,3,4,5,6]这里面 1.count 是1，2.count是2，...6.count是6
如果开始出现count开始不正确了，那么那个数就是重复数

由于数组无序，所以不能直接求count(也可以直接求count 然后把count不正确的选出来 排序，选最小的那个)

但是发现数组里只存在两个状态count正确和不正确，而且重复数在中间点上，而且可以在自然数上有顺序，所以可以用自然数大小作为顺序，根据每个数的count来判断那个重复数在左边还是左边

例如 [1,2,4,4,3,5,6] 2.count是2正确的，所以重复数肯定在右边 3.count是3也是正确的，所以在右边，6.count=7>6，所以在6的左边(不是看数组里的顺序，而是看数的大小自然排列顺序)

所以用二分法，先看mid数的count，一直二分下去找到重复数

## 具体步骤说明：

- 初始化左边界 left 为 1，右边界 right 为数组长度减 1。
- 在每次循环中，计算中间值 mid，然后遍历数组统计小于等于 mid 的数字个数 count。
- 如果 count 小于等于 mid，说明重复的数字在右半部分，更新左边界为 mid + 1；否则在左半部分，更新右边界为 mid - 1。
- 循环终止时，left 即为找到的重复数字。

## 复杂度分析：

- 时间复杂度：二分查找的时间复杂度为 O(log n)，其中 n 是数组的长度。在每次循环中，统计小于等于中间值的数字个数的时间复杂度为 O(n)。
- 空间复杂度：没有使用额外的数据结构，所以空间复杂度为 O(1)。

## 综合点评：

这个解法相对较好，但由于统计小于等于中间值的数字个数可能需要遍历整个数组，所以时间复杂度并不是最优的。
详细注释：

```rust

impl Solution {
    pub fn find_duplicate(mut nums: Vec<i32>) -> i32 {
        let (mut left, mut right) = (1, nums.len() as i32 - 1); // 初始化左右边界
        while left <= right { // 二分查找
            let mid = left + (right - left) / 2; // 计算中间值
            let count = nums.iter().filter(|&&num| num <= mid).count() as i32; // 统计小于等于 mid 的数字个数
            if count <= mid { // 更新边界
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        left // 返回找到的重复数字
    }
}
```
# 解法 8：位运算法
## 题目思路解析：

有重复数的数组和正常1到n的区别是重复的数取代了某个数(不止取代一个)

有重复数的数组.len>比正常1到n.len

这个解法的思路是通过位运算来找到重复的数字。对于每一位，统计数字中二进制展开后该位为 1 的数量，如果x（数组里所有数二进制下该位为1的个数）>y(1到n所有数二进制下该位为1的个数)，说明重复的数该位上是1。
|某个被取代的数某位上的值|重复的数某位上的值|x和y关系|
|-|-|-|
|1|1|x>y|
|0|1|x>y|
|1|0|x<=y|
|0|0|x<=y|

## 具体步骤说明：

- 初始化变量 ans 为 0，bit_max 为数组长度减 1 的二进制展开后最高位的位置（即 32 减去最高位 0 的个数）。
- 对于每一位 bit，统计数字中二进制展开后该位为 1 的数量。对数组中的每个数字，统计其对应位是否为 1，以及索引的对应位是否为 1，分别加入 x 和 y。
- 根据 x 和 y 的比较结果，将 ans 的对应位设置为 0 或 1。
- 最终得到的 ans 即为找到的重复数字。

## 复杂度分析：

- 时间复杂度：两个嵌套循环，外层遍历每一位，内层遍历数组，总体时间复杂度为 O(32n)，即 O(n)，其中 n 是数组的长度。
- 空间复杂度：未使用额外的数据结构，所以空间复杂度为 O(1)。

## 综合点评：

这个解法相对较好，利用了位运算的性质来统计数字中各个位上的信息。
详细注释：

```rust

impl Solution {
    pub fn find_duplicate(mut nums: Vec<i32>) -> i32 {
        let (mut ans, bit_max) = (0, 32 - (nums.len() as i32 - 1).leading_zeros() as i32); // 初始化变量
        for bit in 0..=bit_max { // 遍历每一位
            let (mut x, mut y) = (0, 0); // 统计数字 [1, n] 中二进制展开后第 bit 位为 1 的数量
            for (i, &num) in nums.iter().enumerate() {
                x += (num >> bit) & 1; // 统计数字中该位为 1 的数量
                y += (i as i32 >> bit) & 1; // 统计索引中该位为 1 的数量
            }
            ans |= ((x > y) as i32) << bit; // 根据比较结果更新 ans 的对应位
        }
        ans // 返回最终的重复数字
    }
}
```
# 解法 9：快慢指针法（Floyd's Tortoise and Hare）
## 题目思路解析：

把值当前下一个的索引，在有重复的数组里肯定会有环，例如[1,3,4,2,2,]就是变成 1->3->2->4->2->4->2...
所以用快慢指针来写
low指针每次跑一个，fast跑两个，肯定会在环里相遇(正常追不上)，而且相遇肯定fast至少多跑了一圈，因为只有fast至少反超一圈才能相遇上(想想学校跑步)，而且此时low肯定没有跑完一圈，因为假设在low和fast在入口点出发，low跑完一圈，这时fast刚好跑完两圈，这时候才会相遇，因为fast先进圈的，所以不用等low跑完一圈就可以遇到。
 
b是low和fast相遇点
fast跑了 n圈 总长度是 a+n(b+c)+b=a+(n+1)b+nc 又因为fast跑的是low的两倍
所以 a+(n+1)b+nc=2(a+b)
a=(n-1)(b+c)+c  ，b+c是环长 

所以a==c 所以在起点设一个指针速度也是1，让它和low一起跑，它俩相遇的时候就是在入口

![图片.png](https://pic.leetcode.cn/1691941574-ZkSkZP-%E5%9B%BE%E7%89%87.png)

## 具体步骤说明：

- 初始化快指针 fast 和慢指针 slow 为数组的第一个元素，进入循环。
- 在循环中，快指针每次前进两步，慢指针每次前进一步，直到两个指针相遇，说明存在环。
- 重置慢指针为数组的第一个元素，然后两个指针同时前进一步，直到再次相遇，相遇点即为环的入口，也就是重复的数字。

## 复杂度分析：

- 时间复杂度：快慢指针的遍历过程最多遍历整个数组一次，所以时间复杂度为 O(n)，其中 n 是数组的长度。
- 空间复杂度：只使用了几个额外的变量，所以空间复杂度为 O(1)。

## 综合点评：

这个解法利用了链表环的性质，可以在不修改数组的情况下找到重复的数字。
详细注释：

```rust

impl Solution {
    pub fn find_duplicate(mut nums: Vec<i32>) -> i32 {
        let (mut slow, mut fast) = (0, 0); // 初始化快慢指针
        loop {
            slow = nums[slow] as usize; // 慢指针前进一步
            fast = nums[nums[fast] as usize] as usize; // 快指针前进两步
            if slow == fast { // 检测是否相遇
                break;
            }
        }
        fast = 0; // 重置快指针
        while slow != fast { // 寻找环的入口
            slow = nums[slow] as usize;
            fast = nums[fast] as usize;
        }
        slow as i32 // 返回重复的数字
    }
}
```
