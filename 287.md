Leetcode 287. 寻找重复数.

```rust
impl Solution {
    pub fn find_duplicate( mut nums: Vec<i32>) -> i32 {
    nums.sort();//排序
    let mut prev_num = -1;//表示前一个数
    *nums.iter().find(|&&num| { let found = num == prev_num; prev_num = num; found }).unwrap()//
    }
}
```

```rust
impl Solution {
    pub fn find_duplicate(nums: Vec<i32>) -> i32 {
        let mut count = vec![0; nums.len()];
        *nums.iter().find(|&&num| {
            count[num as usize] += 1;
            count[num as usize] > 1
        }).unwrap()
    }
}
```
```rust
impl Solution {
    pub fn find_duplicate( mut nums: Vec<i32>) -> i32 {
        let mut seen = std::collections::HashSet::new();
        *nums.iter().find(|&&num| {!seen.insert(num)}).unwrap()
    }
}
```
```rust
impl Solution {
    pub fn find_duplicate(mut nums: Vec<i32>) -> i32 {
        for i in 0..nums.len() {
            let val=nums[i].abs();
            if(nums[val as usize]<0){
                return val;
            }
            nums[val as usize]=-nums[val as usize];
        }
        unreachable!()
    }
}
```
```rust
impl Solution {
    pub fn find_duplicate(mut nums: Vec<i32>) -> i32 {
        for i in 0..nums.len() {
            while nums[i]-1!=i as i32 {
                let val=nums[i];
                if(nums[(val-1) as usize]==val){
                    return val;
                }
                nums.swap(i,(val-1) as usize)
            }
        }
        unreachable!()
    }
}
```
```rust
impl Solution {
    pub fn find_duplicate(nums: Vec<i32>) -> i32 {
        *nums.iter()
            .find(|&&num| nums.iter().filter(|&&x| x == num).count() > 1)
            .unwrap()
    }
}
```
```rust
impl Solution {
    pub fn find_duplicate(nums: Vec<i32>) -> i32 {
        let (mut left, mut right) = (1, nums.len() as i32 - 1);
        while left <= right {
            let mid = left + (right - left) / 2;
            let count = nums.iter().filter(|&&num| num <= mid).count() as i32;
            if count <= mid {left = mid + 1;} else {right = mid - 1;}
        }
        left
    }
}
```
```rust
impl Solution {
    pub fn find_duplicate(mut nums: Vec<i32>) -> i32 {
        let (mut ans,bit_max) = (0,32 - (nums.len() as i32 - 1).leading_zeros() as i32);
        for bit in 0..=bit_max {
            let (mut x,mut y)=(0,0); // 统计数字 [1, n] 中二进制展开后第 bit 位为 1 的数量
            for (i, &num) in nums.iter().enumerate() {
                x += (num >> bit) & 1;
                y += (i as i32 >> bit) & 1;
            }
            ans |= ((x > y) as i32 )<< bit;
        }
        ans // 返回最终的重复数字
    }
}
```
```rust
impl Solution {
    pub fn find_duplicate(nums: Vec<i32>) -> i32 {
        let (mut slow, mut fast) = (0, 0);
        loop {
            slow = nums[slow] as usize;
            fast = nums[nums[fast] as usize] as usize;
            if slow == fast { 
                break; 
            }
        }
        fast = 0;
        while slow != fast { 
            slow = nums[slow] as usize; 
            fast = nums[fast] as usize; 
        }
        slow as i32
    }
}
```
